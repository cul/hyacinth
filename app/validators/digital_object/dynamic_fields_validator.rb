# frozen_string_literal: true

# This class provided the logic for validating dynamic fields against a map generated by DynamicFieldMap.
class DigitalObject::DynamicFieldsValidator < ActiveModel::EachValidator
  CORE_TERM_FIELDS = ['uri', 'alt_labels', 'pref_label', 'term_type', 'authority', 'term_type'].freeze

  private

    def generate_errors(digital_object, attribute, value, map)
      errors_for(map, value, attribute).each { |a| digital_object.errors.add(a[0], a[1]) }
    end

    # Returns errors that should be recorded for any of the fields in the data given.
    # Errors include, invalid fields appearing in the data given, field values containing the wrong type of data.
    def errors_for(field_map, data, path = nil)
      errors = []

      data.each do |field_or_group_key, value|
        new_path = [path, field_or_group_key].compact.join('.')

        unless field_map.key?(field_or_group_key)
          errors.append([new_path, "is not a valid field"])
          next
        end

        reduced_map = field_map[field_or_group_key]

        case reduced_map[:type]
        when 'DynamicFieldGroup'
          unless value.is_a?(Array)
            errors.append([new_path, "must contain an array"])
            next
          end

          value.each_with_index do |v, i|
            errors.concat errors_for(reduced_map[:children], v, "#{new_path}[#{i}]")
          end
        when 'DynamicField'
          if (e = field_errors(reduced_map, value))
            errors.concat e.map { |i| [new_path, i] }
          end
        end
      end

      errors
    end

    # Returns any errors that are present for the field and value combination.
    #
    # @return [String] if there are errors
    # @return false if there are no errors
    def field_errors(configuration, value)
      send("errors_for_#{configuration[:field_type]}_field", configuration, value)
    end

    def errors_for_string_field(_configuration, value)
      value.is_a?(String) ? false : ['must be a string']
    end

    def errors_for_textarea_field(configuration, value)
      errors_for_string_field(configuration, value)
    end

    # TODO: Add more specific checks for this field.
    def errors_for_date_field(configuration, value)
      errors_for_string_field(configuration, value)
    end

    # TODO: Add more specific checks for this field. Select value should be one of the configured values.
    def errors_for_select_field(configuration, value)
      errors_for_string_field(configuration, value)
    end

    def errors_for_integer_field(_configuration, value)
      value.is_a?(Integer) ? false : ['must be an integer']
    end

    def errors_for_boolean_field(_configuration, value)
      value.is_a?(TrueClass) || value.is_a?(FalseClass) ? false : ['must be a boolean']
    end

    def errors_for_controlled_term_field(configuration, value)
      return ['must be a controlled term'] unless value.is_a?(Hash)
      return ['must contain a uri or pref_label'] unless value['uri'] || value['pref_label']

      # Check that every value provided is a core field or a valid custom field value for that vocabulary.
      vocabulary = Vocabulary.find_by(string_key: configuration[:controlled_vocabulary])

      return ["#{configuration[:controlled_vocabulary]} is not a valid vocabulary"] unless vocabulary

      valid_fields = CORE_TERM_FIELDS + vocabulary.custom_fields.keys

      errors = (value.keys - valid_fields).map { |f| "has invalid key, \"#{f}\" in hash" }

      errors.empty? ? false : errors
    end
end
